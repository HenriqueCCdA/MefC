/******************************Includes*******************************/
/**/
/*--- Proprios*/
#include <Tipos_Wave.h>
#include <Global_Wave.h>
/*-------------------------------------------------------------------*/
/*********************************************************************/
/**/
/*********************Prototipos das funcoes**************************/
void elmlib(long,short,short);
void assbly(long jd[],long nst);
void pform(long jd[]);
/*********************************************************************/
/**/
/**********************************************************************
 * pform:                                                             *
 * -------------------------------------------------------------------*
**********************************************************************/
void pform(long jd[])
{
  long i,j,no,k,l,nst;
  short type,mat;

    /*é necessario zerar ad e au pela*/ 
/* caso haja mudança no tamanho de ad,au,x ... 
 * mudar essa loop devido a estrutura do solver */
/*===*/  
/*  for(i=0;i<nnode;i++)
   ad[i] = 0.0;
  for(i=0;i<MAXSIST;i++)
   au[i]=0;*/
/*===================================================================*/

/*=== zerando os vetores au e ad*/
  for( i=0 ; i < nnode ; i++ )
     ad[i] = 0.0;
  for( i=0 ; i<= aumax ; i++ )
     au[i] = 0.0;
/*===================================================================*/
  nst = nen*ndf;
  for(i = 0; i < numel; i++)   {
     l = 0;
     for(j = 0; j < nen; j++)   {
       no = elmt[i].node[j];
       xl[0][j] = node[no-1].x;
       xl[1][j] = node[no-1].y;
       if (ndm == 3) xl[2][j] = node[no-1].z;
         u[j] = 0.0;
         v[j] = 0.0;
         a[j] = 0.0;
         for (k = 0; k < ndf; k++)   {
           ld[l++] = node[no-1].eqn[k];
           if (node[no-1].eqn[k] ==-1)
              node[no-1].u[k] = node[no-1].fp[k];
         u[j] = node[no-1].u[k];
         v[j] = node[no-1].v[k];
         a[j] = node[no-1].a[k];
     }
  }
     mat  = elmt[i].mate;
     type = elmt[i].type;
     elmlib(i,type,mat);
     assbly(jd,nst);
  }
}
/*********************************************************************/
/**/
/**********************************************************************
 * assbly:                                                            *
 * -------------------------------------------------------------------*
**********************************************************************/
void assbly(long jd[],long nst)
{
/*===*/
  long i, j, ii, jj, jc;
/*===================================================================*/
/**/
/*===*/
  for (i = 0; i < nst; i++){
   ii = ld[i];
/*+++*/
    if (ii > -1){
      b[ii] = b[ii] - p[i];
      ad[ii] = ad[ii] + s[i][i];
/*...*/
      for (j = 0; j < nst; j++){
/*+++*/
        if (ld[j] > ii)   {
          jc = ld[j];
          jj = jd[jc] - (jc-ii);
          au[jj] = au[jj] + s[i][j];
/*... Tamanho maximo utilizado no vetor au*/
          if(aumax<jj){
            aumax = jj;
           /*...*/
            if ( aumax > MAXSIST ){
              printf("\nTamanha do vetor au inferior ao necessario."
              "\n tamanho maximo = %ld.\n tamanho necessario = %ld.\n"
              "Abortado.\n",MAXSIST,aumax); 
              exit(0);
            }
/*.....................................................................*/
          }
/*.....................................................................*/
        }
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
      }
/*.....................................................................*/
    }
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  }
/*=====================================================================*/
}
/***********************************************************************/


